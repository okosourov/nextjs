"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applySession = void 0;
const cookie_1 = require("cookie");
const nanoid_1 = require("nanoid");
const memory_1 = __importDefault(require("./store/memory"));
const shouldTouch = (cookie, touchAfter) => {
    if (touchAfter === -1 || !cookie.maxAge)
        return false;
    return (cookie.maxAge * 1000 - (cookie.expires.getTime() - Date.now()) >=
        touchAfter);
};
const stringify = (sess) => JSON.stringify(sess, (key, val) => key === 'cookie' || key === 'isNew' || key === 'id' ? undefined : val);
const SESS_PREV = Symbol('session#prev');
const SESS_TOUCHED = Symbol('session#touched');
const commitHead = (req, res, options) => {
    if (res.headersSent || !req.session)
        return;
    if (req.session.isNew || (options.rolling && req[SESS_TOUCHED])) {
        res.setHeader('Set-Cookie', cookie_1.serialize(options.name, options.encode ? options.encode(req.session.id) : req.session.id, {
            path: options.cookie.path,
            httpOnly: options.cookie.httpOnly,
            expires: options.cookie.expires,
            domain: options.cookie.domain,
            sameSite: options.cookie.sameSite,
            secure: options.cookie.secure,
        }));
    }
};
const save = async (req, options) => {
    var _a, _b;
    if (!req.session)
        return;
    const obj = {};
    for (const key in req.session) {
        if (!(key === ('isNew' || key === 'id')))
            obj[key] = req.session[key];
    }
    if (stringify(req.session) !== req[SESS_PREV]) {
        await options.store.__set(req.session.id, obj);
    }
    else if (req[SESS_TOUCHED]) {
        await ((_b = (_a = options.store).__touch) === null || _b === void 0 ? void 0 : _b.call(_a, req.session.id, obj));
    }
};
function setupStore(store) {
    if ('__normalized' in store)
        return store;
    const s = store;
    s.__destroy = function destroy(sid) {
        return new Promise((resolve, reject) => {
            const done = (err) => (err ? reject(err) : resolve());
            const result = this.destroy(sid, done);
            if (result && typeof result.then === 'function')
                result.then(resolve, reject);
        });
    };
    s.__get = function get(sid) {
        return new Promise((resolve, reject) => {
            const done = (err, val) => err ? reject(err) : resolve(val);
            const result = this.get(sid, done);
            if (result && typeof result.then === 'function')
                result.then(resolve, reject);
        });
    };
    s.__set = function set(sid, sess) {
        return new Promise((resolve, reject) => {
            const done = (err) => (err ? reject(err) : resolve());
            const result = this.set(sid, sess, done);
            if (result && typeof result.then === 'function')
                result.then(resolve, reject);
        });
    };
    if (store.touch) {
        s.__touch = function touch(sid, sess) {
            return new Promise((resolve, reject) => {
                const done = (err) => (err ? reject(err) : resolve());
                const result = this.touch(sid, sess, done);
                if (result && typeof result.then === 'function')
                    result.then(resolve, reject);
            });
        };
    }
    s.__normalized = true;
    return s;
}
let memoryStore;
async function applySession(req, res, opts) {
    var _a, _b, _c, _d, _e, _f;
    if (req.session)
        return;
    const options = {
        name: (opts === null || opts === void 0 ? void 0 : opts.name) || 'sid',
        store: setupStore((opts === null || opts === void 0 ? void 0 : opts.store) || (memoryStore = memoryStore || new memory_1.default())),
        genid: (opts === null || opts === void 0 ? void 0 : opts.genid) || nanoid_1.nanoid,
        encode: opts === null || opts === void 0 ? void 0 : opts.encode,
        decode: opts === null || opts === void 0 ? void 0 : opts.decode,
        rolling: (opts === null || opts === void 0 ? void 0 : opts.rolling) || false,
        touchAfter: (opts === null || opts === void 0 ? void 0 : opts.touchAfter) ? opts.touchAfter : 0,
        cookie: {
            path: ((_a = opts === null || opts === void 0 ? void 0 : opts.cookie) === null || _a === void 0 ? void 0 : _a.path) || '/',
            maxAge: ((_b = opts === null || opts === void 0 ? void 0 : opts.cookie) === null || _b === void 0 ? void 0 : _b.maxAge) || null,
            httpOnly: ((_c = opts === null || opts === void 0 ? void 0 : opts.cookie) === null || _c === void 0 ? void 0 : _c.httpOnly) || true,
            domain: ((_d = opts === null || opts === void 0 ? void 0 : opts.cookie) === null || _d === void 0 ? void 0 : _d.domain) || undefined,
            sameSite: (_e = opts === null || opts === void 0 ? void 0 : opts.cookie) === null || _e === void 0 ? void 0 : _e.sameSite,
            secure: ((_f = opts === null || opts === void 0 ? void 0 : opts.cookie) === null || _f === void 0 ? void 0 : _f.secure) || false,
        },
        autoCommit: typeof (opts === null || opts === void 0 ? void 0 : opts.autoCommit) !== 'undefined' ? opts.autoCommit : true,
    };
    let sessId = req.headers && req.headers.cookie
        ? cookie_1.parse(req.headers.cookie)[options.name]
        : null;
    if (sessId && options.decode)
        sessId = options.decode(sessId);
    const sess = sessId ? await options.store.__get(sessId) : null;
    const commit = async () => {
        commitHead(req, res, options);
        await save(req, options);
    };
    const destroy = async () => {
        await options.store.__destroy(req.session.id);
        // This is a valid TS error, but considering its usage, it's fine.
        // @ts-ignore
        delete req.session;
    };
    if (sess) {
        req[SESS_PREV] = stringify(sess);
        const { cookie, ...data } = sess;
        if (typeof cookie.expires === 'string')
            cookie.expires = new Date(cookie.expires);
        req.session = {
            cookie,
            commit,
            destroy,
            isNew: false,
            id: sessId,
        };
        for (const key in data)
            req.session[key] = data[key];
    }
    else {
        req[SESS_PREV] = '{}';
        req.session = {
            cookie: options.cookie,
            commit,
            destroy,
            isNew: true,
            id: nanoid_1.nanoid(),
        };
        if (options.cookie.maxAge)
            req.session.cookie.expires = new Date();
    }
    // Extend session expiry
    if ((req[SESS_TOUCHED] = shouldTouch(req.session.cookie, options.touchAfter))) {
        req.session.cookie.expires = new Date(Date.now() + req.session.cookie.maxAge * 1000);
    }
    // autocommit
    if (options.autoCommit) {
        const oldWritehead = res.writeHead;
        res.writeHead = function resWriteHeadProxy(...args) {
            commitHead(req, res, options);
            return oldWritehead.apply(this, args);
        };
        const oldEnd = res.end;
        res.end = async function resEndProxy(...args) {
            await save(req, options);
            oldEnd.apply(this, args);
        };
    }
    // Compat
    req.sessionStore = options.store;
}
exports.applySession = applySession;
