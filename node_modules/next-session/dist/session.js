"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const cookie_1 = __importDefault(require("./cookie"));
const core_1 = require("./core");
function stringify(sess) {
  return JSON.stringify(sess, (key, val) =>
    key === "cookie" ? undefined : val
  );
}
class Session {
  constructor(res, options, prevSess) {
    if (prevSess) Object.assign(this, prevSess);
    this.cookie = new cookie_1.default(
      prevSess ? prevSess.cookie : options.cookie
    );
    Object.defineProperties(this, {
      id: {
        value:
          (prevSess === null || prevSess === void 0 ? void 0 : prevSess.id) ||
          options.genid(),
      },
      res: { value: res },
      _opts: { value: options },
      isNew: { value: !prevSess, writable: true },
      isDestroyed: { value: false, writable: true },
      _sessStr: { value: prevSess ? stringify(prevSess) : "{}" },
    });
  }
  //  touch the session
  touch() {
    return new Promise((resolve, reject) => {
      this.cookie.resetExpires();
      if (!this._opts.store.touch) return resolve();
      return core_1.isCallbackStore(this._opts.store)
        ? // @ts-ignore
          this._opts.store.touch(this.id, this, (err) =>
            err ? reject(err) : resolve()
          )
        : resolve(this._opts.store.touch(this.id, this));
    });
  }
  //  sessionStore to set this Session
  save() {
    return new Promise((resolve, reject) => {
      if (this.isDestroy) return resolve();
      if (stringify(this) !== this._sessStr) {
        // session has changed
        this.cookie.resetExpires();
        return core_1.isCallbackStore(this._opts.store)
          ? // @ts-ignore
            this._opts.store.set(this.id, this, (err) =>
              err ? reject(err) : resolve()
            )
          : resolve(this._opts.store.set(this.id, this));
      } else if (this.shouldTouch()) {
        // session hasn't changed, try touch
        return resolve(this.touch());
      }
    });
  }
  destroy() {
    this.isDestroy = true;
    return new Promise((resolve, reject) => {
      core_1.isCallbackStore(this._opts.store)
        ? this._opts.store.destroy(this.id, (err) =>
            err ? reject(err) : resolve()
          )
        : resolve(this._opts.store.destroy(this.id));
    });
  }
  shouldTouch() {
    return (
      this._opts.touchAfter !== -1 &&
      this.cookie.maxAge !== null &&
      this.cookie.expires &&
      // Session must be older than touchAfter
      this.cookie.maxAge * 1000 -
        (this.cookie.expires.getTime() - Date.now()) >=
        this._opts.touchAfter
    );
  }
  commitHead() {
    // Header sent, cannot commit
    if (this.res.headersSent) return;
    // Check if new cookie should be set
    if ((this._opts.rolling && this.shouldTouch()) || this.isNew) {
      this.res.setHeader(
        "Set-Cookie",
        this.cookie.serialize(
          this._opts.name,
          this._opts.encode ? this._opts.encode(this.id) : this.id
        )
      );
    }
  }
  async commit() {
    this.commitHead();
    await this.save();
  }
}
exports.default = Session;
